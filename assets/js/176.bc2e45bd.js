(window.webpackJsonp=window.webpackJsonp||[]).push([[176],{537:function(t,e,a){"use strict";a.r(e);var r=a(44),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-api"}},[t._v("#")]),t._v(" React API")]),t._v(" "),a("h3",{attrs:{id:"react-component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-component"}},[t._v("#")]),t._v(" React.Component")]),t._v(" "),a("p",[t._v("如需定义 class 组件，需要继承 React.Component。"),a("br"),t._v("\n在 React.Component 的子类中有个必须定义的 render() 函数。")]),t._v(" "),a("h4",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/",target:"_blank",rel:"noopener noreferrer"}},[t._v("图谱"),a("OutboundLink")],1)]),t._v(" "),a("ul",[a("li",[t._v("挂载\n"),a("ul",[a("li",[a("strong",[t._v("constructor()")]),t._v(" "),a("ul",[a("li",[t._v("如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。")]),t._v(" "),a("li",[t._v("用于初始化state，绑定this 及事件绑定")]),t._v(" "),a("li",[t._v("避免在构造函数中引入任何副作用或订阅（接口请求不应在此）")]),t._v(" "),a("li",[t._v("避免props赋值给state，如果需要，使用"),a("code",[t._v("static getDerivedStateFromProps()")]),t._v("❗️")])])]),t._v(" "),a("li",[t._v("static getDerivedStateFromProps()\n"),a("ul",[a("li",[t._v("state 的值在任何时候都取决于 props")])])]),t._v(" "),a("li",[a("strong",[t._v("render()")]),t._v(" "),a("ul",[a("li",[t._v("继承 React.Component 后唯一必须实现的方法")]),t._v(" "),a("li",[t._v("可返回：React元素、数组或fragments、Protals、String、Number、Boolean 或 Null 类型")]),t._v(" "),a("li",[t._v("应为纯函数，state不变的情况下，返回应该一致")]),t._v(" "),a("li",[t._v("不可修改state，会引起死循环")])])]),t._v(" "),a("li",[a("strong",[t._v("componentDidMount()")]),t._v(" "),a("ul",[a("li",[t._v("用于DOM节点渲染后的副作用操作，如网络请求，添加订阅")]),t._v(" "),a("li",[t._v("不建议直接调用 setState 虽然不会渲染两次，但是会影响性能。除非想在使用 dom 的位置或大小等信息")])])])])]),t._v(" "),a("li",[t._v("更新\n"),a("ul",[a("li",[t._v("static getDerivedStateFromProps()\n"),a("ul",[a("li",[t._v("此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。")])])]),t._v(" "),a("li",[t._v("shouldComponentUpdate()\n"),a("ul",[a("li",[t._v("参数(nextProps, nextState)")]),t._v(" "),a("li",[t._v("返回值决定了 React 组件的输出是否受当前 state 或 props 更改的影响")]),t._v(" "),a("li",[t._v("用于性能优化，如果想特定的阻止更新，使用PureComponent❗️")]),t._v(" "),a("li",[t._v("当返回 false 时，仍可能导致组件重新渲染。")])])]),t._v(" "),a("li",[a("strong",[t._v("render()")])]),t._v(" "),a("li",[t._v("getSnapshotBeforeUpdate()\n"),a("ul",[a("li",[t._v("返回值传递给componentDidUpdate，作为第三个参数")]),t._v(" "),a("li",[t._v("如果返回false，则不调用componentDidUpdate")]),t._v(" "),a("li",[t._v("在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息")])])]),t._v(" "),a("li",[a("strong",[t._v("componentDidUpdate()")]),t._v(" "),a("ul",[a("li",[t._v("参数(prevProps, prevState, snapshot)")]),t._v(" "),a("li")])])])]),t._v(" "),a("li",[t._v("卸载\n"),a("ul",[a("li",[a("strong",[t._v("componentWillUnmount()")]),t._v(" "),a("ul",[a("li",[t._v("注意调用，防止内存泄漏")])])])])]),t._v(" "),a("li",[t._v("错误处理\n"),a("ul",[a("li",[t._v("static getDerivedStateFromError()\n"),a("ul",[a("li",[t._v("此生命周期会在后代组件抛出错误后被调用。它将抛出的错误作为参数，并返回一个值以更新 state")]),t._v(" "),a("li",[t._v("用于发生错误时，处理降级渲染。")])])]),t._v(" "),a("li",[t._v("componentDidCatch()\n"),a("ul",[a("li",[t._v("参数(error, info)")]),t._v(" "),a("li",[t._v("此生命周期在后代组件抛出错误后被调用")]),t._v(" "),a("li",[t._v("会在“提交”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况")])])])])])]),t._v(" "),a("h4",{attrs:{id:"setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState()")]),t._v(" "),a("p",[t._v("setState() 将对组件 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件。"),a("br"),t._v("\nReact 并不会保证 state 的变更会立即生效。"),a("br"),t._v("\n请使用 componentDidUpdate 或者 setState 的回调函数（setState(updater, callback)），这两种方式都可以保证在应用更新后触发。"),a("br"),t._v("\n第一个参数可以传入一个函数(state, props) => stateChange，函数中接收的 state 和 props 都保证为最新。"),a("br"),t._v("\n第一个参数还可以接受对象。"),a("br"),t._v("\n第二个参数为可选的回调函数，它将在 setState 完成合并并重新渲染组件后执行。")]),t._v(" "),a("h4",{attrs:{id:"forceupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#forceupdate"}},[t._v("#")]),t._v(" forceUpdate()")]),t._v(" "),a("p",[t._v("可以跳过本组件的shouldComponentUpdate生命周期，强制执行重新渲染。"),a("br"),t._v("\n适用场景是有个状态更新了，但这个状态没有使用 state 或 props 维护，又想更新渲染，则需要主动调用该方法。")]),t._v(" "),a("h4",{attrs:{id:"defaultprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defaultprops"}},[t._v("#")]),t._v(" defaultProps")]),t._v(" "),a("p",[t._v("该属性为子组件设置默认值")]),t._v(" "),a("h4",{attrs:{id:"displayname"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#displayname"}},[t._v("#")]),t._v(" displayName")]),t._v(" "),a("p",[t._v("displayName 字符串多用于调试消息。")]),t._v(" "),a("h4",{attrs:{id:"props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" props")]),t._v(" "),a("p",[t._v("this.props.children是一个特殊的props属性")]),t._v(" "),a("h4",{attrs:{id:"state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" state")]),t._v(" "),a("hr"),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"react-purecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-purecomponent"}},[t._v("#")]),t._v(" React.PureComponent")]),t._v(" "),a("p",[t._v("未实现 shouldComponentUpdate()"),a("br"),t._v("\n浅层对比 prop 和 state")]),t._v(" "),a("h3",{attrs:{id:"react-memo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-memo"}},[t._v("#")]),t._v(" React.memo")]),t._v(" "),a("p",[t._v("React.memo 为高阶组件。"),a("br"),t._v("\nReact.memo 仅检查 props 变更。"),a("br"),t._v("\n此方法仅作为性能优化的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。"),a("br"),t._v("\n使用常见见"),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate",target:"_blank",rel:"noopener noreferrer"}},[t._v("我该如何实现 shouldComponentUpdate?"),a("OutboundLink")],1),a("br"),t._v("\nReact.memo 等效于 PureComponent，但它只比较 props。")]),t._v(" "),a("h3",{attrs:{id:"react-createelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-createelement"}},[t._v("#")]),t._v(" React.createElement()")]),t._v(" "),a("p",[t._v("创建并返回指定的React元素。")]),t._v(" "),a("h3",{attrs:{id:"react-cloneelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-cloneelement"}},[t._v("#")]),t._v(" React.cloneElement()")]),t._v(" "),a("p",[t._v("以 element 元素为样板克隆并返回新的 React 元素。")]),t._v(" "),a("h3",{attrs:{id:"react-isvalidelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-isvalidelement"}},[t._v("#")]),t._v(" React.isValidElement()")]),t._v(" "),a("p",[t._v("验证是否是React元素，返回布尔值")]),t._v(" "),a("h3",{attrs:{id:"react-children"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-children"}},[t._v("#")]),t._v(" React.Children")]),t._v(" "),a("p",[t._v("用于处理this.props.children")]),t._v(" "),a("ul",[a("li",[t._v("React.Children.map")]),t._v(" "),a("li",[t._v("React.Children.forEach")]),t._v(" "),a("li",[t._v("React.Children.count 组件数量")]),t._v(" "),a("li",[t._v("React.Children.only 是否只有一个子节点")]),t._v(" "),a("li",[t._v("React.Children.toArray 将节点树水平展开")])]),t._v(" "),a("h3",{attrs:{id:"react-fragment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-fragment"}},[t._v("#")]),t._v(" React.Fragment")]),t._v(" "),a("p",[t._v("React元素，简写"),a("code",[t._v("<></>")])]),t._v(" "),a("h3",{attrs:{id:"react-createref-❗️"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-createref-❗️"}},[t._v("#")]),t._v(" React.createRef()❗️")]),t._v(" "),a("p",[t._v("React.createRef 创建一个能够通过 ref 属性附加到 React 元素的 ref。")]),t._v(" "),a("h3",{attrs:{id:"react-forwardref❗️"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-forwardref❗️"}},[t._v("#")]),t._v(" React.forwardRef❗️")]),t._v(" "),a("p",[t._v("React.forwardRef 会创建一个React组件，这个组件能够将其接收的 ref 属性转发到其组件树下的另一个组件中。")]),t._v(" "),a("h3",{attrs:{id:"react-lazy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-lazy"}},[t._v("#")]),t._v(" React.lazy")]),t._v(" "),a("p",[t._v("React.lazy() 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。")]),t._v(" "),a("h3",{attrs:{id:"react-suspense"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-suspense"}},[t._v("#")]),t._v(" React.Suspense")]),t._v(" "),a("p",[t._v("React.Suspense 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。"),a("br"),t._v("\n目前仅支持React.lazy")]),t._v(" "),a("hr"),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"reactdom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactdom"}},[t._v("#")]),t._v(" ReactDOM")]),t._v(" "),a("h3",{attrs:{id:"render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[t._v("#")]),t._v(" render()")]),t._v(" "),a("p",[a("code",[t._v("ReactDOM.render(element, container[, callback])")]),a("br"),t._v("\n在提供的 container 里渲染一个 React 元素，并返回对该组件的引用（或者针对无状态组件返回 null）。"),a("br"),t._v("\n如果提供了可选的回调函数，该回调将在组件被渲染或更新之后被执行。")]),t._v(" "),a("h3",{attrs:{id:"hydrate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hydrate"}},[t._v("#")]),t._v(" hydrate()")]),t._v(" "),a("p",[t._v("用于服务端渲染")]),t._v(" "),a("h3",{attrs:{id:"unmountcomponentatnode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unmountcomponentatnode"}},[t._v("#")]),t._v(" unmountComponentAtNode()")]),t._v(" "),a("p",[t._v("从 DOM 中卸载组件，会将其事件处理器（event handlers）和 state 一并清除。")]),t._v(" "),a("h3",{attrs:{id:"finddomnode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#finddomnode"}},[t._v("#")]),t._v(" findDOMNode()")]),t._v(" "),a("p",[t._v("findDOMNode 是一个访问底层 DOM 节点的应急方案（escape hatch）。")]),t._v(" "),a("h3",{attrs:{id:"createportal-❗️"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#createportal-❗️"}},[t._v("#")]),t._v(" createPortal()❗️")]),t._v(" "),a("p",[t._v("应用场景可参考"),a("code",[t._v("/react-doc/src/component/Portals")]),a("br"),t._v("\n创建 portal。Portal 将提供一种将子节点渲染到 DOM 节点中的方式，该节点存在于 DOM 组件的层次结构之外。")]),t._v(" "),a("hr"),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"其他-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他-api"}},[t._v("#")]),t._v(" 其他 API")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/events.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("事件 API"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);