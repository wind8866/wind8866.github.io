(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{431:function(t,s,a){"use strict";a.r(s);var n=a(44),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"问题汇总"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题汇总"}},[t._v("#")]),t._v(" 问题汇总")]),t._v(" "),a("ul",[a("li",[t._v("[ ] 类好像没办法成为 Number 一样的转换函数，类只能使用 new 操作符调用")]),t._v(" "),a("li",[t._v("[ ] 类中如何创建 prototype 的属性")])]),t._v(" "),a("p",[t._v("类中如何创建非 prototype 的方法")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("fun2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("fun")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fun3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// fun 和 fun2 都在 this 上，fun3 在原形链上")]),t._v("\n")])])]),a("p",[t._v("使用 class 语法，我想让 Rabbit 继承 Animal 的 type 作为属性怎么办？有这种需求吗？（使用super？）"),a("br"),t._v("\n代码见 "),a("RouterLink",{attrs:{to:"/javascript/3.html"}},[t._v("rabbit3")])],1),t._v(" "),a("h2",{attrs:{id:"class-基本语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-基本语法"}},[t._v("#")]),t._v(" Class 基本语法")]),t._v(" "),a("p",[t._v("使用传统方式创建的构造函数和类的区别")]),t._v(" "),a("ul",[a("li",[t._v("类会有特殊的 "),a("code",[t._v("[[IsClassConstructor]]: true")]),t._v(" 标记\n"),a("ul",[a("li",[t._v("类 toString 会以 class 开头")]),t._v(" "),a("li",[t._v("必须使用 new 调用")])])]),t._v(" "),a("li",[t._v("类方法不可枚举")]),t._v(" "),a("li",[t._v('类总是严格模式 "use strict"')])]),t._v(" "),a("p",[t._v("类中设置的方法默认在 prototype 上，属性默认在 对象自身上。"),a("br"),t._v("\n类的方法是箭头函数，那么 this 始终指向该类")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/javascript/1.html"}},[t._v("课后习题:1.html")])],1),t._v(" "),a("h2",{attrs:{id:"类继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类继承"}},[t._v("#")]),t._v(" 类继承")]),t._v(" "),a("p",[t._v('我们希望在父类方法的基础上进行调整或扩展其功能。我们在我们的方法中做一些事儿，但是在它之前或之后或在过程中会调用父类方法。Class 为此提供了 "super" 关键字。'),a("br"),t._v("\nsuper.method(...) 调用父类的方法。"),a("br"),t._v("\n箭头函数没有 super，如果被访问，它会从外部函数获取。"),a("br"),t._v("\n继承类的 constructor 必须调用 super(...)，并且 (!) 一定要在使用 this 之前调用。"),a("br"),t._v('\n派生构造器具有特殊的内部属性 [[ConstructorKind]]:"derived"。这是一个特殊的内部标签。该标签会影响它的 new 行为：')]),t._v(" "),a("ul",[a("li",[t._v("当通过 new 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 this。")]),t._v(" "),a("li",[t._v("但是当继承的 constructor 执行时，它不会执行此操作。它期望父类的 constructor 来完成这项工作。"),a("br"),t._v("\n因此，派生的 constructor 必须调用 super 才能执行其父类（base）的 constructor，否则 this 指向的那个对象将不会被创建。并且我们会收到一个报错。"),a("br"),t._v("\n需要知道子类声明与父类相同的属性不会生效，因为 super 会在之后执行，但方法可行"),a("br"),t._v("\n看代码4，父类 this 的属性值并不会像 "),a("code",[t._v("rabbit.prototype = new Animal()")]),t._v(" 一样直接添加为子类的原形的属性。")])]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/javascript/2.html"}},[t._v("课后习题:2.html")]),a("br"),t._v(" "),a("RouterLink",{attrs:{to:"/javascript/3.html"}},[t._v("使用 ES5 语法模拟一个类的实现")])],1),t._v(" "),a("ul",[a("li",[t._v("[ ] "),a("a",{attrs:{href:"https://zh.javascript.info/class-inheritance#shen-ru-nei-bu-tan-jiu-he-homeobject",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入了解原理的难知识"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"静态属性和静态方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态属性和静态方法"}},[t._v("#")]),t._v(" 静态属性和静态方法")]),t._v(" "),a("p",[t._v("使用 static 创建的静态方法保存在类中，方法中的this指向类本身，而非类的构造函数。"),a("br"),t._v("\n静态属性和方法是可被继承的。使用 extends 会自动继承。"),a("br"),t._v(" "),a("RouterLink",{attrs:{to:"/javascript/4.html"}},[t._v("课后习题:4.html")])],1),t._v(" "),a("h2",{attrs:{id:"私有的和受保护的属性和方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#私有的和受保护的属性和方法"}},[t._v("#")]),t._v(" 私有的和受保护的属性和方法")]),t._v(" "),a("p",[t._v("一个属性可以有许多设定：")]),t._v(" "),a("ul",[a("li",[t._v("私有：外部不可访问")]),t._v(" "),a("li",[t._v("改写：不可修改")]),t._v(" "),a("li",[t._v("继承：是否继承给子类")])]),t._v(" "),a("p",[t._v("私有字段与公共字段不会发生冲突。我们可以同时拥有私有的 #waterAmount 和公共的 waterAmount 字段。"),a("br"),t._v("\n如果一个 class 的使用者想要改变那些本不打算被从外部更改的东西 —— 后果是不可预测的。"),a("br"),t._v(" "),a("RouterLink",{attrs:{to:"/javascript/5.html"}},[t._v("5.html")])],1),t._v(" "),a("h2",{attrs:{id:"扩展内建类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展内建类"}},[t._v("#")]),t._v(" 扩展内建类")]),t._v(" "),a("p",[t._v("通常，当一个类扩展另一个类时，静态方法和非静态方法都会被继承。这已经在 静态属性和静态方法 中详细地解释过了。"),a("br"),t._v("\n但内建类却是一个例外。它们相互间不继承静态方法。"),a("br"),t._v("\n感觉 "),a("code",[t._v("Symbol.species")]),t._v(" 只是改变了指向，基本没有用。"),a("br"),t._v(" "),a("RouterLink",{attrs:{to:"/javascript/6.html"}},[t._v("6.html")])],1),t._v(" "),a("h2",{attrs:{id:"类检查-instanceof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类检查-instanceof"}},[t._v("#")]),t._v(" 类检查 instanceof")]),t._v(" "),a("p",[t._v("Symbol.hasInstance 可以改变 instanceof 的行为，大多数 class 没有 Symbol.hasInstance。在这种情况下，标准的逻辑是：使用 obj instanceOf Class 检查 Class.prototype 是否等于 obj 的原型链中的原型之一。")]),t._v(" "),a("p",[a("code",[t._v("obj instanceof Class")]),t._v(" 相当于 "),a("code",[t._v("Class.prototype.isPrototypeOf(obj)")])]),t._v(" "),a("p",[t._v("终极秘笈，对于 JS 中内置的值，可以使用 "),a("code",[t._v("Object.prototype.toString.call(value)")]),t._v(" 来判断。"),a("br"),t._v("\n自己可以使用 Symbol.toStringTag 自定义对象 toString 方法的行为，一般不需要这么做。"),a("br"),t._v("\n环境中已经有些值设置了该属性，例如")]),t._v(" "),a("ul",[a("li",[t._v("window: [object Window]")]),t._v(" "),a("li",[t._v("document: [object HTMLDocument]")]),t._v(" "),a("li",[t._v("document.createElement('input'): [object HTMLInputElement]")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("知道值为原始数据类型"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" value\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("原始数据类型"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 内建对象"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"mixin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mixin"}},[t._v("#")]),t._v(" Mixin")]),t._v(" "),a("p",[t._v("一些其它编程语言允许多重继承。JavaScript 不支持多重继承，但是可以通过将方法拷贝到原型中来实现 mixin。"),a("br"),t._v("\n如果 Mixins 意外覆盖了现有类的方法，那么它们可能会成为一个冲突点。因此，通常应该仔细考虑 mixin 的命名方法，以最大程度地降低发生这种冲突的可能性。"),a("br"),t._v("\n一般使用 "),a("code",[t._v("Object.assign(User.prototype, sayHiMixin)")]),t._v(" 语法")]),t._v(" "),a("ul",[a("li",[t._v("[ ] 实现一个 EventMixin")])])])}),[],!1,null,null,null);s.default=r.exports}}]);