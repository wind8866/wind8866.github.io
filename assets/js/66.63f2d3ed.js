(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{427:function(t,v,_){"use strict";_.r(v);var r=_(44),a=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[t._v("#")]),t._v(" 对象")]),t._v(" "),_("p",[t._v("delete 可以移除属性"),_("br"),t._v("\n使用 in 操作符可以判断属性是否存在"),_("br"),t._v("\n遍历一个对象时，整数属性会被进行排序，其他属性则按照创建的顺序显示")]),t._v(" "),_("h2",{attrs:{id:"对象的引用和赋值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象的引用和赋值"}},[t._v("#")]),t._v(" 对象的引用和赋值")]),t._v(" "),_("p",[t._v("将一个变量赋值给另一个变量；函数返回一个值；函数接受一个参数，都会进行值拷贝。但要注意的是对象变量存储的是地址，拷贝也会拷贝地址。拷贝后对该值进行操作，实际是对地址指向的对象进行操作。")]),t._v(" "),_("h2",{attrs:{id:"垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),_("p",[t._v("JS 判断是否进入垃圾回收的依据是该值的可达性。"),_("br"),t._v("\n定期执行以下“垃圾回收”步骤：")]),t._v(" "),_("ul",[_("li",[t._v("垃圾收集器找到所有的根，并“标记”（记住）它们。")]),t._v(" "),_("li",[t._v("然后它遍历并“标记”来自它们的所有引用。")]),t._v(" "),_("li",[t._v("然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。")]),t._v(" "),_("li",[t._v("……如此操作，直到所有可达的（从根部）引用都被访问到。")]),t._v(" "),_("li",[t._v("没有被标记的对象都会被删除。")])]),t._v(" "),_("h2",{attrs:{id:"对象方法-this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象方法-this"}},[t._v("#")]),t._v(' 对象方法，"this"')]),t._v(" "),_("p",[t._v("this 指向调用者，没有调用者，this 指向 undefined。非严格模式下 this 指向 window。"),_("br"),t._v("\n箭头函数中的变量都指向定义时的所处环境，this 也是这样，箭头函数没有自己的 this。")]),t._v(" "),_("h2",{attrs:{id:"构造函数与-new-操作符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构造函数与-new-操作符"}},[t._v("#")]),t._v(" 构造函数与 new 操作符")]),t._v(" "),_("p",[t._v("使用 new 创建对象时。")]),t._v(" "),_("ol",[_("li",[t._v("创建一个新的空对象并分配给 this")]),t._v(" "),_("li",[t._v("执行构造函数（通常会修改 this）")]),t._v(" "),_("li",[t._v("返回 this")])]),t._v(" "),_("p",[t._v("函数内可通过使用 new.target 判断调用函数时是否使用了 new 操作符。"),_("br"),t._v("\n通常构造器没有 return 语句")]),t._v(" "),_("h2",{attrs:{id:"可选链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可选链"}},[t._v("#")]),t._v(' 可选链 "?."')]),t._v(" "),_("p",[t._v("不要过度使用可选链，仅在数据可能为其他非对象类型时使用。例如 user.name ，user是必须为对象的，name是可选的，我们应该写作 user.name?.firstName 而不是 user?.name?.firstName。这样利于调试"),_("br"),t._v("\n正如前面所说的，如果 ?. 左边部分不存在，就会立即停止运算（“短路效应”）。"),_("br"),t._v("\n函数的调用需要?.()"),_("br"),t._v("\n对象取值的另一种方法?.[]")]),t._v(" "),_("h2",{attrs:{id:"symbol-类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#symbol-类型"}},[t._v("#")]),t._v(" Symbol 类型")]),t._v(" "),_("p",[t._v("Symbol 不会自动转换为字符串，可以使用toSrging转换"),_("br"),t._v("\nSymbol 用作对象键值的好处："),_("br"),t._v("\n1、可以创建私有属性和私有方法。"),_("br"),t._v("\n2、在使用第三方库时可以防止命名冲突覆盖属性")]),t._v(" "),_("p",[t._v("一般的遍历会忽略 Symbol 作为键值的属性")]),t._v(" "),_("p",[t._v('全局 Symbol，使用 Symbol.for("id") 创建，没有 "id" 时创建，有时返回。'),_("br"),t._v("\nSymbol.keyFor(sym) 接收一个全局 Symbol，返回 Symbol 的名字。")]),t._v(" "),_("p",[t._v("JS官方很多默认的属性是使用 Symbol 实现的")]),t._v(" "),_("h2",{attrs:{id:"对象-原始值转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象-原始值转换"}},[t._v("#")]),t._v(" 对象 — 原始值转换")]),t._v(" "),_("p",[t._v("当一个对象被用在需要原始值的上下文中时，例如，在 alert 或数学运算中，对象会被转换为原始值"),_("br"),t._v("\n只有三种转化机制：")]),t._v(" "),_("ul",[_("li",[t._v("number")]),t._v(" "),_("li",[t._v("default")]),t._v(" "),_("li",[t._v("string")])]),t._v(" "),_("p",[t._v("没有 boolean 机制，因为对象都转化为 true")]),t._v(" "),_("p",[t._v("为了进行转换，JavaScript 尝试查找并调用三个对象方法：")]),t._v(" "),_("ol",[_("li",[t._v("调用 "),_("code",[t._v("obj[Symbol.toPrimitive](hint)")]),t._v(" —— 带有 symbol 键 Symbol.toPrimitive（系统 symbol）的方法，如果这个方法存在的话，")]),t._v(" "),_("li",[t._v('否则，如果 hint 是 "string" —— 尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。')]),t._v(" "),_("li",[t._v('否则，如果 hint 是 "number" 或 "default" —— 尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。')]),t._v(" "),_("li",[t._v("如果经过以上结果都没有返回原始类型，则会报错")])]),t._v(" "),_("p",[t._v('({}).toString 默认返回 "[Object Object]"，({}).valueOf 默认返回对象自己。')])])}),[],!1,null,null,null);v.default=a.exports}}]);