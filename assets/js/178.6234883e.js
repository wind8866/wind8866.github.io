(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{539:function(e,r,t){"use strict";t.r(r);var n=t(44),v=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"文档笔记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文档笔记"}},[e._v("#")]),e._v(" 文档笔记")]),e._v(" "),t("h1",{attrs:{id:"实例代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例代码"}},[e._v("#")]),e._v(" 实例代码")]),e._v(" "),t("p",[e._v("/items/react-doc")]),e._v(" "),t("h2",{attrs:{id:"文档笔记-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文档笔记-2"}},[e._v("#")]),e._v(" 文档笔记")]),e._v(" "),t("p",[e._v("JSX也是一种表达式"),t("br"),e._v("\n组件的状态名，应以组件自身的角度命名，不应该依赖调用者。"),t("br"),e._v("\n如果一部分 UI 足够复杂或组件可被多次使用，那么他应该被独立成组件"),t("br"),e._v("\n所有的 React 组件必须像纯函数一样保护他的 props 不被修改。"),t("br"),e._v("\n不参与数据流的值可以放在 "),t("code",[e._v("this")]),e._v(" 对象里。"),t("br"),e._v("\n不要直接修改 this.state"),t("br"),e._v("\n📌"),t("strong",[e._v("State 的更新可能是异步，setState传入函数可同步更新。")]),t("br"),e._v("\nState 的更新会被合并，只需使用setState更新需要修改的部分即可。"),t("br"),e._v("\nReact 是自上而下的单向数据流。"),t("br"),e._v("\n阻止浏览器默认事件使用"),t("code",[e._v("e.preventDefault()")]),t("br"),e._v("\n&& 与 || 都会阻断执行，&& 前面的值转化为 true 才执行并返回后面的代码，|| 前面值转化为为 false 才会执行后面的代码。也可以用 ES6 中的 ?? 操作符。"),t("br"),e._v("\n区分受控组件与非受控组件的方法是 value 是否为 null 或 undefined，若是，则是非受控组件。所以受控组件的 value 值应该是空字符串。"),t("br"),e._v("\n多个组件需要反映相同的变化数据，应该将共享状态提升到最近的共同父组件中去。"),t("br"),e._v("\n在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。"),t("br"),e._v("\n📌"),t("strong",[e._v("组件可以作为参数传递给子组件")]),t("br"),e._v(" "),t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html#specialization",target:"_blank",rel:"noopener noreferrer"}},[e._v("特例关系"),t("OutboundLink")],1),e._v("：“特殊”组件可以通过 props 定制并渲染“一般”组件。"),t("br"),e._v("\nReact中不会用到继承，都是组合。"),t("br"),e._v("\n使用 "),t("code",[e._v("<React.Fragment>")]),e._v(" 或 "),t("code",[e._v("<>")]),e._v(" 可设置一个空的包含组件。")]),e._v(" "),t("p",[t("strong",[e._v("高阶组件")]),t("br"),e._v("\n📌高阶组件（HOC）是参数为组件，返回值为新组件的函数。"),t("br"),e._v("\nHOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。"),t("br"),e._v("\nHOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的。"),t("br"),e._v("\nHOC 是一种基于 React 的组合特性而形成的设计模式。")]),e._v(" "),t("p",[t("strong",[e._v("性能优化：")])]),e._v(" "),t("ul",[t("li",[e._v("使用Create React App，生产环境打包、使用 Brunch、envify、uglifyify、terser 进行打包。")]),e._v(" "),t("li",[e._v("对长列表使用虚拟滚动器。")]),e._v(" "),t("li",[e._v("📌在特定情况下，在 "),t("code",[e._v("shouldComponentUpdate")]),e._v(" 生命周期返回false进行拦截，使其不进行render。")]),e._v(" "),t("li",[e._v("工具："),t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab",target:"_blank",rel:"noopener noreferrer"}},[e._v("使用"),t("OutboundLink")],1),e._v("React的Chrome插件可以监控组件渲染的时机，用于进行性能优化。"),t("br"),e._v("\n可以使用 React.PureComponent 替代手动的 shouldComponentUpdate 生命周期渲染拦截。该对比使用浅比较")])]),e._v(" "),t("p",[e._v("因为JSX会被编译为 "),t("code",[e._v("React.createElement")]),e._v("，所以必须在文件头部引入 "),t("code",[e._v("React")]),e._v(" 。"),t("br"),e._v("\n📌Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。使用 "),t("code",[e._v("ReactDOM.createPortal(child, container)")]),e._v(" 可以创建"),t("br"),e._v("\n📌只要在React的DOM树中存在父子关系，父元素即可以捕获子元素触发的冒泡事件。"),t("br"),e._v("\n📌Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差，可以使用Hooks替代。"),t("br"),e._v("\n如果一个很深的组件需要顶层组件传递参数，为了避免属性特别多且层层传递的问题，一种比较好的设计方式是将很深的组件放在顶层组件中，将该组件层层传递。但带来的问题是顶层组件会变得复杂。"),t("br"),e._v("\nContext 的值中尽量不要传递对象，传递可能会"),t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/context.html#caveats",target:"_blank",rel:"noopener noreferrer"}},[e._v("触发意外渲染"),t("OutboundLink")],1),e._v("。"),t("br"),e._v("\n📌一个良好的软件应该有明确的错误反馈，使用错误边界可以 catch 到一些意外的错误情况。"),t("br"),e._v("\n📌自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。（测试错误会向上传递，导致所有的程序都出现错误而被 React 移除）"),t("br"),e._v("\n使用 React 边界捕获无法捕获：事件处理、异步代码、服务端渲染、组件自身抛出的错误。")]),e._v(" "),t("p",[t("strong",[e._v("适合使用Ref的情况：")]),t("br"),e._v("\n在非必要情况下，不要使用Ref。")]),e._v(" "),t("ul",[t("li",[e._v("管理焦点，文本选择或媒体播放。")]),e._v(" "),t("li",[e._v("触发强制动画。")]),e._v(" "),t("li",[e._v("集成第三方 DOM 库。")])]),e._v(" "),t("p",[e._v("默认你不能在函数组件上使用 ref 属性，因为它们没有实例。"),t("br"),e._v("\n📌Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref。"),t("br"),e._v("\nRef 不仅可以传递 dom，可以传递其他数据（优先使用状态）。")]),e._v(" "),t("p",[e._v("📌"),t("strong",[e._v("diff算法的设计")])]),e._v(" "),t("ul",[t("li",[e._v("在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步。")]),e._v(" "),t("li",[e._v("因为算法复杂度的问题，react 设计了一套 O(n) 复杂度的算法，这个算法有两个前提。\n"),t("ul",[t("li",[e._v("两个不同类型的元素会产生出不同的树")]),e._v(" "),t("li",[e._v("开发者可以通过 key 来暗示哪些子元素在不同的渲染下能保持稳定")])])])]),e._v(" "),t("p",[e._v("不同类型的元素，即使子元素是完全一样的，在dom更换时，子元素仍然会重新渲染。所以应该尽量避免这种情况。"),t("br"),e._v("\n渲染逻辑"),t("br"),e._v("\n1、对比不同类型的元素时，React 会拆卸原有的树并且建立起新的树。"),t("br"),e._v("\n2、对比同一元素，尽可能的最小化更新该元素的属性。"),t("br"),e._v("\n3、对比同类型的组件，组件实例不变，仅传入当前状态的 props，然后调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法。在 render() 时进行diff的计算，并根据计算更新 dom。="),t("br"),e._v("\n4、对没有使用 key 的子节点进行递归时，对变化前后的两个 dom 树的值逐个比较，在最后插入元素开销较小，在开始插入元素，开销最大。（有点像数组）"),t("br"),e._v("\n5、对子节点进行递归，key 的作用体现出来，key 标记了数据与某个 dom 节点的对应关系。使得diff能够更精确的对比，dom 更新更精确的最小化。")]),e._v(" "),t("p",[t("strong",[e._v("render prop")]),t("br"),e._v("\n术语 “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术。"),t("br"),e._v("\n使用 Render Props 来解决横切关注点（Cross-Cutting Concerns）"),t("br"),e._v("\n任何被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”."),t("br"),e._v("\nRender Props 是一种实现方式，给组件传入一个函数，该函数在组件内部执行，返回JSX，该组件中封装了方法，状态，其中状态可以返回给函数。这就相当于一个完整的组件，组件内部的一部分内容你可以自己定义，我会给你一些数据。不使用组件参数，使用子元素同样能实现该功能。")]),e._v(" "),t("p",[e._v("可以使用"),t("code",[e._v("<React.StrictMode>")]),e._v("开启严格模式，用于检查过时 API、ref 副作用等等问题。"),t("br"),e._v("\n如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。"),t("br"),e._v("\nreact 中的事件都是在冒泡阶段触发的，如需注册捕获阶段的事件处理函数，则应为事件名添加 Capture。例如，处理捕获阶段的点击事件请使用 onClickCapture，而不是 onClick。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/dom-elements.html",target:"_blank",rel:"noopener noreferrer"}},[t("strong",[e._v("react 中的替代：")]),t("OutboundLink")],1),t("br"),e._v("\n在 React 中，所有的 DOM 特性和属性（包括事件处理）都应该是小驼峰命名的方式。例外的情况是 aria-* 以及 data-* 属性，一律使用小写字母命名。"),t("br"),e._v("\n特殊：")]),e._v(" "),t("ul",[t("li",[e._v("checkbox 受控 checkbox，defaultChecked 非受控默认值")]),e._v(" "),t("li",[e._v("class 替换为 classname")]),e._v(" "),t("li",[e._v("dangerouslySetInnerHTML 为 innerHTML 替代方案")]),e._v(" "),t("li",[e._v("htmlFor代替for")]),e._v(" "),t("li",[e._v("onChange，react修改了onChange行为。")]),e._v(" "),t("li",[e._v("select 内的 selected 使用 value 替代")]),e._v(" "),t("li",[e._v("style，修改了默认行为，React 会自动添加 ”px” 后缀到内联样式为数字的属性后。")]),e._v(" "),t("li",[e._v("value 为受控值，非受控组件使用 defaultValue 为表单元素设置默认值。")]),e._v(" "),t("li",[e._v("textarea 内的值使用 value 属性替代")])]),e._v(" "),t("h2",{attrs:{id:"demo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#demo"}},[e._v("#")]),e._v(" Demo")]),e._v(" "),t("p",[e._v("在另一个项目：")])])}),[],!1,null,null,null);r.default=v.exports}}]);